// THIS CODE WAS GENERATED BY SH4GENERATOR v0.1.0 BY FRANCISZEK ŁOPUSZAŃSKI
#![allow(unused)]
use crate::{
    cpu::CPU,
    opcodes::{OpCode, OpCodeArgs},
};

#[allow(non_snake_case)]
impl CPU {
    fn sign_extend(x: u16) -> i32 {
        if (x & 0x80) == 0 {
            x as i32 & 0x000_000FF
        } else {
            x as i32 | 0xFFFF_FF00u32 as i32
        }
    }

    fn usign_extend(x: u16) -> u32 {
        if (x & 0x80) == 0 {
            x as u32 & 0x000_000FF
        } else {
            x as u32 | 0xFFFF_FF00
        }
    }

    pub fn execute(&mut self, opcode: OpCode) {
        match opcode.id {
            0 => self.MOV(opcode.args),
            1 => self.MOVI(opcode.args),
            4 => self.MOVA(opcode.args),
            5 => self.MOVWI(opcode.args),
            6 => self.MOVLI(opcode.args),
            7 => self.MOVBL(opcode.args),
            8 => self.MOVWL(opcode.args),
            9 => self.MOVLL(opcode.args),
            10 => self.MOVBS(opcode.args),
            11 => self.MOVWS(opcode.args),
            12 => self.MOVLS(opcode.args),
            13 => self.MOVBP(opcode.args),
            14 => self.MOVWP(opcode.args),
            15 => self.MOVLP(opcode.args),
            16 => self.MOVBM(opcode.args),
            17 => self.MOVWM(opcode.args),
            18 => self.MOVLM(opcode.args),
            25 => self.MOVBL4(opcode.args),
            28 => self.MOVWL4(opcode.args),
            31 => self.MOVLL4(opcode.args),
            33 => self.MOVBS4(opcode.args),
            35 => self.MOVWS4(opcode.args),
            37 => self.MOVLS4(opcode.args),
            39 => self.MOVBL0(opcode.args),
            40 => self.MOVWL0(opcode.args),
            41 => self.MOVLL0(opcode.args),
            42 => self.MOVBS0(opcode.args),
            43 => self.MOVWS0(opcode.args),
            44 => self.MOVLS0(opcode.args),
            45 => self.MOVBLG(opcode.args),
            46 => self.MOVWLG(opcode.args),
            47 => self.MOVLLG(opcode.args),
            48 => self.MOVBSG(opcode.args),
            49 => self.MOVWSG(opcode.args),
            50 => self.MOVLSG(opcode.args),
            51 => self.MOVCO(opcode.args),
            52 => self.MOVLINK(opcode.args),
            53 => self.MOVUAL(opcode.args),
            54 => self.MOVUALP(opcode.args),
            60 => self.MOVT(opcode.args),
            62 => self.SWAPB(opcode.args),
            63 => self.SWAPW(opcode.args),
            64 => self.XTRCT(opcode.args),
            79 => self.ADD(opcode.args),
            80 => self.ADDI(opcode.args),
            81 => self.ADDC(opcode.args),
            82 => self.ADDV(opcode.args),
            83 => self.CMPIM(opcode.args),
            84 => self.CMPEQ(opcode.args),
            85 => self.CMPHI(opcode.args),
            86 => self.CMPGE(opcode.args),
            87 => self.CMPHI_DUP(opcode.args),
            88 => self.CMPGT(opcode.args),
            89 => self.CMPPL(opcode.args),
            90 => self.CMPPZ(opcode.args),
            91 => self.CMPSTR(opcode.args),
            96 => self.DIV0S(opcode.args),
            97 => self.DIV0U(opcode.args),
            98 => self.DIV1(opcode.args),
            101 => self.DMULS(opcode.args),
            102 => self.DMULU(opcode.args),
            103 => self.DT(opcode.args),
            104 => self.EXTSB(opcode.args),
            105 => self.EXTSW(opcode.args),
            106 => self.EXTUB(opcode.args),
            107 => self.EXTUW(opcode.args),
            108 => self.MACL(opcode.args),
            109 => self.MACW(opcode.args),
            110 => self.MULL(opcode.args),
            112 => self.MULS(opcode.args),
            113 => self.MULU(opcode.args),
            114 => self.NEG(opcode.args),
            115 => self.NEGC(opcode.args),
            116 => self.SUB(opcode.args),
            117 => self.SUBC(opcode.args),
            118 => self.SUBV(opcode.args),
            119 => self.AND(opcode.args),
            120 => self.ANDI(opcode.args),
            121 => self.ANDM(opcode.args),
            122 => self.NOT(opcode.args),
            123 => self.OR(opcode.args),
            124 => self.ORI(opcode.args),
            125 => self.ORM(opcode.args),
            126 => self.TAS(opcode.args),
            127 => self.TST(opcode.args),
            128 => self.TSTI(opcode.args),
            129 => self.TSTM(opcode.args),
            130 => self.XOR(opcode.args),
            131 => self.XORI(opcode.args),
            132 => self.XORM(opcode.args),
            133 => self.ROTCL(opcode.args),
            134 => self.ROTCR(opcode.args),
            135 => self.ROTL(opcode.args),
            136 => self.ROTR(opcode.args),
            137 => self.SHAD(opcode.args),
            138 => self.SHAL(opcode.args),
            139 => self.SHAR(opcode.args),
            140 => self.SHLD(opcode.args),
            141 => self.SHLL(opcode.args),
            142 => self.SHLL2(opcode.args),
            143 => self.SHLL8(opcode.args),
            144 => self.SHLL16(opcode.args),
            145 => self.SHLR(opcode.args),
            146 => self.SHLR2(opcode.args),
            147 => self.SHLR8(opcode.args),
            148 => self.SHLR16(opcode.args),
            149 => self.BF(opcode.args),
            150 => self.BFS(opcode.args),
            151 => self.BT(opcode.args),
            152 => self.BTS(opcode.args),
            153 => self.BRA(opcode.args),
            154 => self.BRAF(opcode.args),
            155 => self.BSR(opcode.args),
            156 => self.BSRF(opcode.args),
            157 => self.JMP(opcode.args),
            158 => self.JSR(opcode.args),
            161 => self.RTS(opcode.args),
            164 => self.CLRMAC(opcode.args),
            165 => self.CLRS(opcode.args),
            166 => self.CLRT(opcode.args),
            167 => self.ICBI(opcode.args),
            169 => self.LDCSR(opcode.args),
            170 => self.LDCMSR(opcode.args),
            172 => self.LDCGBR(opcode.args),
            173 => self.LDCMGBR(opcode.args),
            174 => self.LDCVBR(opcode.args),
            175 => self.LDCMVBR(opcode.args),
            182 => self.LDCSGR(opcode.args),
            183 => self.LDCMSGR(opcode.args),
            184 => self.LDCSSR(opcode.args),
            185 => self.LDCMSSR(opcode.args),
            186 => self.LDCSPC(opcode.args),
            187 => self.LDCMSPC(opcode.args),
            188 => self.LDCDBR(opcode.args),
            189 => self.LDCMDBR(opcode.args),
            190 => self.LDCRn_BANK(opcode.args),
            191 => self.LDCMRn_BANK(opcode.args),
            194 => self.LDSMACH(opcode.args),
            195 => self.LDSMMACH(opcode.args),
            196 => self.LDSMACL(opcode.args),
            197 => self.LDSMMACL(opcode.args),
            198 => self.LDSPR(opcode.args),
            199 => self.LDSMPR(opcode.args),
            212 => self.LDTLB(opcode.args),
            213 => self.MOVCAL(opcode.args),
            214 => self.NOP(opcode.args),
            215 => self.OCBI(opcode.args),
            216 => self.OCBP(opcode.args),
            217 => self.OCBWB(opcode.args),
            218 => self.PREF(opcode.args),
            219 => self.PREFI(opcode.args),
            221 => self.RTE(opcode.args),
            224 => self.SETS(opcode.args),
            225 => self.SETT(opcode.args),
            226 => self.SLEEP(opcode.args),
            228 => self.STCSR(opcode.args),
            229 => self.STCMSR(opcode.args),
            231 => self.STCGBR(opcode.args),
            232 => self.STCMGBR(opcode.args),
            233 => self.STCVBR(opcode.args),
            234 => self.STCMVBR(opcode.args),
            241 => self.STCSGR(opcode.args),
            242 => self.STCMSGR(opcode.args),
            243 => self.STCSSR(opcode.args),
            244 => self.STCMSSR(opcode.args),
            245 => self.STCSPC(opcode.args),
            246 => self.STCMSPC(opcode.args),
            247 => self.STCDBR(opcode.args),
            248 => self.STCMDBR(opcode.args),
            249 => self.STCRm_BANK(opcode.args),
            250 => self.STCMRm_BANK(opcode.args),
            251 => self.STSMACH(opcode.args),
            252 => self.STSMMACH(opcode.args),
            253 => self.STSMACL(opcode.args),
            254 => self.STSMMACL(opcode.args),
            255 => self.STSPR(opcode.args),
            256 => self.STSMPR(opcode.args),
            269 => self.SYNCO(opcode.args),
            270 => self.TRAPA(opcode.args),
            271 => self.FMOV(opcode.args),
            272 => self.FMOV_LOAD(opcode.args),
            273 => self.FMOV_STORE(opcode.args),
            274 => self.FMOV_RESTORE(opcode.args),
            275 => self.FMOV_SAVE(opcode.args),
            276 => self.FMOV_INDEX_LOAD(opcode.args),
            277 => self.FMOV_INDEX_STORE(opcode.args),
            280 => self.FMOV_DR(opcode.args),
            281 => self.FMOV_DRXD(opcode.args),
            282 => self.FMOV_XDDR(opcode.args),
            283 => self.FMOV_XDXD(opcode.args),
            284 => self.FMOV_LOAD_DR(opcode.args),
            285 => self.FMOV_LOAD_XD(opcode.args),
            286 => self.FMOV_STORE_DR(opcode.args),
            287 => self.FMOV_STORE_XD(opcode.args),
            288 => self.FMOV_RESTORE_DR(opcode.args),
            289 => self.FMOV_RESTORE_XD(opcode.args),
            290 => self.FMOV_SAVE_DR(opcode.args),
            291 => self.FMOV_SAVE_XD(opcode.args),
            292 => self.FMOV_INDEX_LOAD_DR(opcode.args),
            293 => self.FMOV_INDEX_LOAD_XD(opcode.args),
            294 => self.FMOV_INDEX_STORE_DR(opcode.args),
            295 => self.FMOV_INDEX_STORE_XD(opcode.args),
            298 => self.FLDI0(opcode.args),
            299 => self.FLDI1(opcode.args),
            300 => self.FLDS(opcode.args),
            301 => self.FSTS(opcode.args),
            302 => self.FABS(opcode.args),
            303 => self.FNEG(opcode.args),
            304 => self.FADD(opcode.args),
            305 => self.FSUB(opcode.args),
            306 => self.FMUL(opcode.args),
            307 => self.FMAC(opcode.args),
            308 => self.FDIV(opcode.args),
            309 => self.FSQRT(opcode.args),
            310 => self.FCMP_EQ(opcode.args),
            311 => self.FCMP_GT(opcode.args),
            312 => self.FLOAT_single(opcode.args),
            313 => self.FTRC_single(opcode.args),
            314 => self.FIPR(opcode.args),
            315 => self.FTRV(opcode.args),
            316 => self.FSRRA(opcode.args),
            317 => self.FSCA(opcode.args),
            318 => self.FABS_DUP(opcode.args),
            319 => self.FNEG_DUP(opcode.args),
            320 => self.FADD_DUP(opcode.args),
            321 => self.FSUB_DUP(opcode.args),
            322 => self.FMUL_DUP(opcode.args),
            323 => self.FDIV_DUP(opcode.args),
            324 => self.FSQRT_DUP(opcode.args),
            325 => self.FCMP_EQ_DUP(opcode.args),
            326 => self.FCMP_GT_DUP(opcode.args),
            327 => self.FLOAT_double(opcode.args),
            328 => self.FTRC_double(opcode.args),
            329 => self.FCNVDS(opcode.args),
            330 => self.FCNVSD(opcode.args),
            331 => self.LDSFPSCR(opcode.args),
            332 => self.STSFPSCR(opcode.args),
            333 => self.LDSMFPSCR(opcode.args),
            334 => self.STSMFPSCR(opcode.args),
            335 => self.LDSFPUL(opcode.args),
            336 => self.STSFPUL(opcode.args),
            337 => self.LDSMFPUL(opcode.args),
            338 => self.STSMFPUL(opcode.args),
            339 => self.FRCHG(opcode.args),
            340 => self.FSCHG(opcode.args),
            341 => self.FPCHG(opcode.args),

            _ => {
                println!("OUT OF RANGE OPCODE: {:#?}", opcode);
                todo!()
            }
        }
    }

    pub fn MOV(&mut self, args: OpCodeArgs) {
        /* Rm -> Rn */
        self.registers.r[args.n as usize] = self.registers.r[args.m as usize];
        self.registers.pc += 2;
    }

    pub fn MOVI(&mut self, args: OpCodeArgs) {
        /* imm -> sign extension -> Rn */
        todo!()
    }

    pub fn MOVA(&mut self, args: OpCodeArgs) {
        /*
         (disp*4) + (PC & 0xFFFFFFFC) + 4 -> R0
        */
        todo!()
    }

    pub fn MOVWI(&mut self, args: OpCodeArgs) {
        /*
         (disp*2 + PC + 4) -> sign extension -> Rn
        */
        todo!()
    }

    pub fn MOVLI(&mut self, args: OpCodeArgs) {
        /*
         (disp*4 + (PC & 0xFFFFFFFC) + 4) -> sign extension -> Rn
        */
        todo!()
    }

    pub fn MOVBL(&mut self, args: OpCodeArgs) {
        /* (Rm) -> sign extension -> Rn */
        todo!()
    }

    pub fn MOVWL(&mut self, args: OpCodeArgs) {
        /* (Rm) -> sign extension -> Rn */
        todo!()
    }

    pub fn MOVLL(&mut self, args: OpCodeArgs) {
        /* (Rm) -> Rn */
        todo!()
    }

    pub fn MOVBS(&mut self, args: OpCodeArgs) {
        /* Rm -> (Rn) */
        todo!()
    }

    pub fn MOVWS(&mut self, args: OpCodeArgs) {
        /* Rm -> (Rn) */
        todo!()
    }

    pub fn MOVLS(&mut self, args: OpCodeArgs) {
        /* Rm -> (Rn) */
        todo!()
    }

    pub fn MOVBP(&mut self, args: OpCodeArgs) {
        /*
         (Rm) -> sign extension -> Rn, Rm+1 -> Rm
        */
        todo!()
    }

    pub fn MOVWP(&mut self, args: OpCodeArgs) {
        /*
         (Rm) -> sign extension -> Rn, Rm+2 -> Rm
        */
        todo!()
    }

    pub fn MOVLP(&mut self, args: OpCodeArgs) {
        /* (Rm) -> Rn, Rm+4 -> Rm */
        todo!()
    }

    pub fn MOVBM(&mut self, args: OpCodeArgs) {
        /* Rn-1 -> Rn, Rm -> (Rn) */
        todo!()
    }

    pub fn MOVWM(&mut self, args: OpCodeArgs) {
        /* Rn-2 -> Rn, Rm -> (Rn) */
        todo!()
    }

    pub fn MOVLM(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, Rm -> (Rn) */
        todo!()
    }

    pub fn MOVBL4(&mut self, args: OpCodeArgs) {
        /* (disp + Rm) -> sign extension -> R0 */
        todo!()
    }

    pub fn MOVWL4(&mut self, args: OpCodeArgs) {
        /*
         (disp*2 + Rm) -> sign extension -> R0
        */
        todo!()
    }

    pub fn MOVLL4(&mut self, args: OpCodeArgs) {
        /* (disp*4 + Rm) -> Rn */
        todo!()
    }

    pub fn MOVBS4(&mut self, args: OpCodeArgs) {
        /* R0 -> (disp + Rn) */
        todo!()
    }

    pub fn MOVWS4(&mut self, args: OpCodeArgs) {
        /* R0 -> (disp*2 + Rn) */
        todo!()
    }

    pub fn MOVLS4(&mut self, args: OpCodeArgs) {
        /* Rm -> (disp*4 + Rn) */
        todo!()
    }

    pub fn MOVBL0(&mut self, args: OpCodeArgs) {
        /* (R0 + Rm) -> sign extension -> Rn */
        todo!()
    }

    pub fn MOVWL0(&mut self, args: OpCodeArgs) {
        /* (R0 + Rm) -> sign extension -> Rn */
        todo!()
    }

    pub fn MOVLL0(&mut self, args: OpCodeArgs) {
        /* (R0 + Rm) -> Rn */
        todo!()
    }

    pub fn MOVBS0(&mut self, args: OpCodeArgs) {
        /* Rm -> (R0 + Rn) */
        todo!()
    }

    pub fn MOVWS0(&mut self, args: OpCodeArgs) {
        /* Rm -> (R0 + Rn) */
        todo!()
    }

    pub fn MOVLS0(&mut self, args: OpCodeArgs) {
        /* Rm -> (R0 + Rn) */
        todo!()
    }

    pub fn MOVBLG(&mut self, args: OpCodeArgs) {
        /* (disp + GBR) -> sign extension -> R0 */
        todo!()
    }

    pub fn MOVWLG(&mut self, args: OpCodeArgs) {
        /*
         (disp*2 + GBR) -> sign extension -> R0
        */
        todo!()
    }

    pub fn MOVLLG(&mut self, args: OpCodeArgs) {
        /* (disp*4 + GBR) -> R0 */
        todo!()
    }

    pub fn MOVBSG(&mut self, args: OpCodeArgs) {
        /* R0 -> (disp + GBR) */
        todo!()
    }

    pub fn MOVWSG(&mut self, args: OpCodeArgs) {
        /* R0 -> (disp*2 + GBR) */
        todo!()
    }

    pub fn MOVLSG(&mut self, args: OpCodeArgs) {
        /* R0 -> (disp*4 + GBR) */
        todo!()
    }

    pub fn MOVCO(&mut self, args: OpCodeArgs) {
        /*
         LDST -> T If (T == 1): R0 -> Rn 0 -> LDST
        */
        todo!()
    }

    pub fn MOVLINK(&mut self, args: OpCodeArgs) {
        /*
         1 -> LDST (Rm) -> R0 When interrupt/exception occured: 0 ->
         LDST
        */
        todo!()
    }

    pub fn MOVUAL(&mut self, args: OpCodeArgs) {
        /*
         (Rm) -> R0 Load non-boundary alignment data
        */
        todo!()
    }

    pub fn MOVUALP(&mut self, args: OpCodeArgs) {
        /*
         (Rm) -> R0, Rm + 4 -> Rm Load non-boundary alignment data
        */
        todo!()
    }

    pub fn MOVT(&mut self, args: OpCodeArgs) {
        /* T -> Rn */
        todo!()
    }

    pub fn SWAPB(&mut self, args: OpCodeArgs) {
        /* Rm -> swap lower 2 bytes -> Rn */
        todo!()
    }

    pub fn SWAPW(&mut self, args: OpCodeArgs) {
        /* Rm -> swap upper/lower words -> Rn */
        todo!()
    }

    pub fn XTRCT(&mut self, args: OpCodeArgs) {
        /* Rm:Rn middle 32 bits -> Rn */
        todo!()
    }

    pub fn ADD(&mut self, args: OpCodeArgs) {
        /* Rn + Rm -> Rn */
        self.registers.r[args.n as usize] += self.registers.r[args.m as usize];
        self.registers.pc += 2;
    }

    pub fn ADDI(&mut self, args: OpCodeArgs) {
        /* Rn + (sign extension)imm */
        self.registers.r[args.n as usize] += CPU::usign_extend(args.i);
        self.registers.pc += 2;
    }

    pub fn ADDC(&mut self, args: OpCodeArgs) {
        /* Rn + Rm + T -> Rn, carry -> T */
        todo!()
    }

    pub fn ADDV(&mut self, args: OpCodeArgs) {
        /* Rn + Rm -> Rn, overflow -> T */
        todo!()
    }

    pub fn CMPIM(&mut self, args: OpCodeArgs) {
        /*
         If R0 = (sign extension)imm: 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn CMPEQ(&mut self, args: OpCodeArgs) {
        /* If Rn = Rm: 1 -> T Else: 0 -> T */
        todo!()
    }

    pub fn CMPHI(&mut self, args: OpCodeArgs) {
        /*
         If Rn >= Rm (unsigned): 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn CMPGE(&mut self, args: OpCodeArgs) {
        /*
         If Rn >= Rm (signed): 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn CMPHI_DUP(&mut self, args: OpCodeArgs) {
        /*
         If Rn > Rm (unsigned): 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn CMPGT(&mut self, args: OpCodeArgs) {
        /*
         If Rn > Rm (signed): 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn CMPPL(&mut self, args: OpCodeArgs) {
        /*
         If Rn > 0 (signed): 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn CMPPZ(&mut self, args: OpCodeArgs) {
        /*
         If Rn >= 0 (signed): 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn CMPSTR(&mut self, args: OpCodeArgs) {
        /*
         If Rn and Rm have an equal byte: 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn DIV0S(&mut self, args: OpCodeArgs) {
        /*
         MSB of Rn -> Q, MSB of Rm -> M, M ^ Q -> T
        */
        todo!()
    }

    pub fn DIV0U(&mut self, args: OpCodeArgs) {
        /* 0 -> M, 0 -> Q, 0 -> T */
        todo!()
    }

    pub fn DIV1(&mut self, args: OpCodeArgs) {
        /* 1-step division (Rn / Rm) */
        todo!()
    }

    pub fn DMULS(&mut self, args: OpCodeArgs) {
        /*
         Signed, Rn * Rm -> MACH:MACL 32 * 32 -> 64 bits
        */
        todo!()
    }

    pub fn DMULU(&mut self, args: OpCodeArgs) {
        /*
         Unsigned, Rn * Rm -> MACH:MACL 32 * 32 -> 64 bits
        */
        todo!()
    }

    pub fn DT(&mut self, args: OpCodeArgs) {
        /*
         Rn-1 -> Rn If Rn = 0: 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn EXTSB(&mut self, args: OpCodeArgs) {
        /* Rm sign-extended from byte -> Rn */
        todo!()
    }

    pub fn EXTSW(&mut self, args: OpCodeArgs) {
        /* Rm sign-extended from word -> Rn */
        todo!()
    }

    pub fn EXTUB(&mut self, args: OpCodeArgs) {
        /* Rm zero-extended from byte -> Rn */
        todo!()
    }

    pub fn EXTUW(&mut self, args: OpCodeArgs) {
        /* Rm zero-extended from word -> Rn */
        todo!()
    }

    pub fn MACL(&mut self, args: OpCodeArgs) {
        /*
         Signed, (Rn) * (Rm) + MAC -> MAC 32 * 32 + 64 -> 64 bits
        */
        todo!()
    }

    pub fn MACW(&mut self, args: OpCodeArgs) {
        /*
         Signed, (Rn) * (Rm) + MAC -> MAC SH1: 16 * 16 + 42 -> 42 bits
         Other: 16 * 16 + 64 -> 64 bits
        */
        todo!()
    }

    pub fn MULL(&mut self, args: OpCodeArgs) {
        /* Rn * Rm -> MACL 32 * 32 -> 32 bits */
        todo!()
    }

    pub fn MULS(&mut self, args: OpCodeArgs) {
        /*
         Signed, Rn * Rm -> MACL 16 * 16 -> 32 bits
        */
        todo!()
    }

    pub fn MULU(&mut self, args: OpCodeArgs) {
        /*
         Unsigned, Rn * Rm -> MACL 16 * 16 -> 32 bits
        */
        todo!()
    }

    pub fn NEG(&mut self, args: OpCodeArgs) {
        /* 0 - Rm -> Rn */
        todo!()
    }

    pub fn NEGC(&mut self, args: OpCodeArgs) {
        /* 0 - Rm - T -> Rn, borrow -> T */
        todo!()
    }

    pub fn SUB(&mut self, args: OpCodeArgs) {
        /* Rn - Rm -> Rn */
        todo!()
    }

    pub fn SUBC(&mut self, args: OpCodeArgs) {
        /* Rn - Rm - T -> Rn, borrow -> T */
        todo!()
    }

    pub fn SUBV(&mut self, args: OpCodeArgs) {
        /* Rn - Rm -> Rn, underflow -> T */
        todo!()
    }

    pub fn AND(&mut self, args: OpCodeArgs) {
        /* Rn & Rm -> Rn */
        todo!()
    }

    pub fn ANDI(&mut self, args: OpCodeArgs) {
        /* R0 & (zero extend)imm -> R0 */
        todo!()
    }

    pub fn ANDM(&mut self, args: OpCodeArgs) {
        /*
         (R0 + GBR) & (zero extend)imm -> (R0 + GBR)
        */
        todo!()
    }

    pub fn NOT(&mut self, args: OpCodeArgs) {
        /* ~Rm -> Rn */
        todo!()
    }

    pub fn OR(&mut self, args: OpCodeArgs) {
        /* Rn | Rm -> Rn */
        todo!()
    }

    pub fn ORI(&mut self, args: OpCodeArgs) {
        /* R0 | (zero extend)imm -> R0 */
        todo!()
    }

    pub fn ORM(&mut self, args: OpCodeArgs) {
        /*
         (R0 + GBR) | (zero extend)imm -> (R0 + GBR)
        */
        todo!()
    }

    pub fn TAS(&mut self, args: OpCodeArgs) {
        /*
         If (Rn) = 0: 1 -> T Else: 0 -> T 1 -> MSB of (Rn)
        */
        todo!()
    }

    pub fn TST(&mut self, args: OpCodeArgs) {
        /*
         If Rn & Rm = 0: 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn TSTI(&mut self, args: OpCodeArgs) {
        /*
         If R0 & (zero extend)imm = 0: 1 -> T Else: 0 -> T
        */
        todo!()
    }

    pub fn TSTM(&mut self, args: OpCodeArgs) {
        /*
         If (R0 + GBR) & (zero extend)imm = 0: 1 -> T Else 0: -> T
        */
        todo!()
    }

    pub fn XOR(&mut self, args: OpCodeArgs) {
        /* Rn ^ Rm -> Rn */
        todo!()
    }

    pub fn XORI(&mut self, args: OpCodeArgs) {
        /* R0 ^ (zero extend)imm -> R0 */
        todo!()
    }

    pub fn XORM(&mut self, args: OpCodeArgs) {
        /*
         (R0 + GBR) ^ (zero extend)imm -> (R0 + GBR)
        */
        todo!()
    }

    pub fn ROTCL(&mut self, args: OpCodeArgs) {
        /* T << Rn << T */
        todo!()
    }

    pub fn ROTCR(&mut self, args: OpCodeArgs) {
        /* T >> Rn >> T */
        todo!()
    }

    pub fn ROTL(&mut self, args: OpCodeArgs) {
        /* T << Rn << MSB */
        todo!()
    }

    pub fn ROTR(&mut self, args: OpCodeArgs) {
        /* LSB >> Rn >> T */
        todo!()
    }

    pub fn SHAD(&mut self, args: OpCodeArgs) {
        /*
         If Rm >= 0: Rn << Rm -> Rn If Rm < 0: Rn >> |Rm|
         -> [MSB -> Rn]
        */
        todo!()
    }

    pub fn SHAL(&mut self, args: OpCodeArgs) {
        /* T << Rn << 0 */
        todo!()
    }

    pub fn SHAR(&mut self, args: OpCodeArgs) {
        /* MSB >> Rn >> T */
        todo!()
    }

    pub fn SHLD(&mut self, args: OpCodeArgs) {
        /*
         If Rm >= 0: Rn << Rm -> Rn If Rm < 0: Rn >> |Rm|
         -> [0 -> Rn]
        */
        todo!()
    }

    pub fn SHLL(&mut self, args: OpCodeArgs) {
        /* T << Rn << 0 */
        todo!()
    }

    pub fn SHLL2(&mut self, args: OpCodeArgs) {
        /* Rn << 2 -> Rn */
        todo!()
    }

    pub fn SHLL8(&mut self, args: OpCodeArgs) {
        /* Rn << 8 -> Rn */
        todo!()
    }

    pub fn SHLL16(&mut self, args: OpCodeArgs) {
        /* Rn << 16 -> Rn */
        todo!()
    }

    pub fn SHLR(&mut self, args: OpCodeArgs) {
        /* 0 >> Rn >> T */
        todo!()
    }

    pub fn SHLR2(&mut self, args: OpCodeArgs) {
        /* Rn >> 2 -> [0 -> Rn] */
        todo!()
    }

    pub fn SHLR8(&mut self, args: OpCodeArgs) {
        /* Rn >> 8 -> [0 -> Rn] */
        todo!()
    }

    pub fn SHLR16(&mut self, args: OpCodeArgs) {
        /* Rn >> 16 -> [0 -> Rn] */
        todo!()
    }

    pub fn BF(&mut self, args: OpCodeArgs) {
        /*
         If T = 0: disp*2 + PC + 4 -> PC Else: nop
        */
        todo!()
    }

    pub fn BFS(&mut self, args: OpCodeArgs) {
        /*
         If T = 0: disp*2 + PC + 4 -> PC Else: nop (Delayed branch)
        */
        todo!()
    }

    pub fn BT(&mut self, args: OpCodeArgs) {
        /*
         If T = 1: disp*2 + PC + 4 -> PC Else: nop
        */
        todo!()
    }

    pub fn BTS(&mut self, args: OpCodeArgs) {
        /*
         If T = 1: disp*2 + PC + 4 -> PC Else: nop (Delayed branch)
        */
        todo!()
    }

    pub fn BRA(&mut self, args: OpCodeArgs) {
        /* disp*2 + PC + 4 -> PC (Delayed branch) */
        todo!()
    }

    pub fn BRAF(&mut self, args: OpCodeArgs) {
        /* Rm + PC + 4 -> PC (Delayed branch) */
        todo!()
    }

    pub fn BSR(&mut self, args: OpCodeArgs) {
        /*
         PC + 4 -> PR, disp*2 + PC + 4 -> PC (Delayed branch)
        */
        todo!()
    }

    pub fn BSRF(&mut self, args: OpCodeArgs) {
        /*
         PC + 4 -> PR, Rm + PC + 4 -> PC (Delayed branch)
        */
        todo!()
    }

    pub fn JMP(&mut self, args: OpCodeArgs) {
        /* Rm -> PC (Delayed branch) */
        todo!()
    }

    pub fn JSR(&mut self, args: OpCodeArgs) {
        /*
         PC + 4 -> PR, Rm -> PC (Delayed branch)
        */
        todo!()
    }

    pub fn RTS(&mut self, args: OpCodeArgs) {
        /* PR -> PC Delayed branch */
        todo!()
    }

    pub fn CLRMAC(&mut self, args: OpCodeArgs) {
        /* 0 -> MACH, 0 -> MACL */
        todo!()
    }

    pub fn CLRS(&mut self, args: OpCodeArgs) {
        /* 0 -> S */
        todo!()
    }

    pub fn CLRT(&mut self, args: OpCodeArgs) {
        /* 0 -> T */
        todo!()
    }

    pub fn ICBI(&mut self, args: OpCodeArgs) {
        /*
         Invalidate instruction cache block indicated by logical address
        */
        todo!()
    }

    pub fn LDCSR(&mut self, args: OpCodeArgs) {
        /* Rm -> SR */
        todo!()
    }

    pub fn LDCMSR(&mut self, args: OpCodeArgs) {
        /* (Rm) -> SR, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDCGBR(&mut self, args: OpCodeArgs) {
        /* Rm -> GBR */
        todo!()
    }

    pub fn LDCMGBR(&mut self, args: OpCodeArgs) {
        /* (Rm) -> GBR, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDCVBR(&mut self, args: OpCodeArgs) {
        /* Rm -> VBR */
        todo!()
    }

    pub fn LDCMVBR(&mut self, args: OpCodeArgs) {
        /* (Rm) -> VBR, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDCSGR(&mut self, args: OpCodeArgs) {
        /* Rm -> SGR */
        todo!()
    }

    pub fn LDCMSGR(&mut self, args: OpCodeArgs) {
        /* (Rm) -> SGR, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDCSSR(&mut self, args: OpCodeArgs) {
        /* Rm -> SSR */
        todo!()
    }

    pub fn LDCMSSR(&mut self, args: OpCodeArgs) {
        /* (Rm) -> SSR, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDCSPC(&mut self, args: OpCodeArgs) {
        /* Rm -> SPC */
        todo!()
    }

    pub fn LDCMSPC(&mut self, args: OpCodeArgs) {
        /* (Rm) -> SPC, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDCDBR(&mut self, args: OpCodeArgs) {
        /* Rm -> DBR */
        todo!()
    }

    pub fn LDCMDBR(&mut self, args: OpCodeArgs) {
        /* (Rm) -> DBR, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDCRn_BANK(&mut self, args: OpCodeArgs) {
        /* Rm -> Rn_BANK (n = 0-7) */
        todo!()
    }

    pub fn LDCMRn_BANK(&mut self, args: OpCodeArgs) {
        /* (Rm) -> Rn_BANK, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDSMACH(&mut self, args: OpCodeArgs) {
        /* Rm -> MACH */
        todo!()
    }

    pub fn LDSMMACH(&mut self, args: OpCodeArgs) {
        /* (Rm) -> MACH, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDSMACL(&mut self, args: OpCodeArgs) {
        /* Rm -> MACL */
        todo!()
    }

    pub fn LDSMMACL(&mut self, args: OpCodeArgs) {
        /* (Rm) -> MACL, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDSPR(&mut self, args: OpCodeArgs) {
        /* Rm -> PR */
        todo!()
    }

    pub fn LDSMPR(&mut self, args: OpCodeArgs) {
        /* (Rm) -> PR, Rm+4 -> Rm */
        todo!()
    }

    pub fn LDTLB(&mut self, args: OpCodeArgs) {
        /* PTEH/PTEL -> TLB */
        todo!()
    }

    pub fn MOVCAL(&mut self, args: OpCodeArgs) {
        /*
         R0 -> (Rn) (without fetching cache block)
        */
        todo!()
    }

    pub fn NOP(&mut self, args: OpCodeArgs) {
        /* No operation */
        todo!()
    }

    pub fn OCBI(&mut self, args: OpCodeArgs) {
        /* Invalidate operand cache block */
        todo!()
    }

    pub fn OCBP(&mut self, args: OpCodeArgs) {
        /*
         Write back and invalidate operand cache block
        */
        todo!()
    }

    pub fn OCBWB(&mut self, args: OpCodeArgs) {
        /* Write back operand cache block */
        todo!()
    }

    pub fn PREF(&mut self, args: OpCodeArgs) {
        /* (Rn) -> operand cache */
        todo!()
    }

    pub fn PREFI(&mut self, args: OpCodeArgs) {
        /*
         Reads 32-byte instruction block into instruction cache
        */
        todo!()
    }

    pub fn RTE(&mut self, args: OpCodeArgs) {
        /*
         Delayed branch SH1*,SH2*: stack area -> PC/SR SH3*,SH4*: SSR/SPC
         -> SR/PC
        */
        todo!()
    }

    pub fn SETS(&mut self, args: OpCodeArgs) {
        /* 1 -> S */
        todo!()
    }

    pub fn SETT(&mut self, args: OpCodeArgs) {
        /* 1 -> T */
        todo!()
    }

    pub fn SLEEP(&mut self, args: OpCodeArgs) {
        /* Sleep or standby */
        todo!()
    }

    pub fn STCSR(&mut self, args: OpCodeArgs) {
        /* SR -> Rn */
        todo!()
    }

    pub fn STCMSR(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, SR -> (Rn) */
        todo!()
    }

    pub fn STCGBR(&mut self, args: OpCodeArgs) {
        /* GBR -> Rn */
        todo!()
    }

    pub fn STCMGBR(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, GBR -> (Rn) */
        todo!()
    }

    pub fn STCVBR(&mut self, args: OpCodeArgs) {
        /* VBR -> Rn */
        todo!()
    }

    pub fn STCMVBR(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, VBR -> (Rn) */
        todo!()
    }

    pub fn STCSGR(&mut self, args: OpCodeArgs) {
        /* SGR -> Rn */
        todo!()
    }

    pub fn STCMSGR(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, SGR -> (Rn) */
        todo!()
    }

    pub fn STCSSR(&mut self, args: OpCodeArgs) {
        /* SSR -> Rn */
        todo!()
    }

    pub fn STCMSSR(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, SSR -> (Rn) */
        todo!()
    }

    pub fn STCSPC(&mut self, args: OpCodeArgs) {
        /* SPC -> Rn */
        todo!()
    }

    pub fn STCMSPC(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, SPC -> (Rn) */
        todo!()
    }

    pub fn STCDBR(&mut self, args: OpCodeArgs) {
        /* DBR -> Rn */
        todo!()
    }

    pub fn STCMDBR(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, DBR -> (Rn) */
        todo!()
    }

    pub fn STCRm_BANK(&mut self, args: OpCodeArgs) {
        /* Rm_BANK -> Rn (m = 0-7) */
        todo!()
    }

    pub fn STCMRm_BANK(&mut self, args: OpCodeArgs) {
        /*
         Rn-4 -> Rn, Rm_BANK -> (Rn) (m = 0-7)
        */
        todo!()
    }

    pub fn STSMACH(&mut self, args: OpCodeArgs) {
        /* MACH -> Rn */
        todo!()
    }

    pub fn STSMMACH(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, MACH -> (Rn) */
        todo!()
    }

    pub fn STSMACL(&mut self, args: OpCodeArgs) {
        /* MACL -> Rn */
        todo!()
    }

    pub fn STSMMACL(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, MACL -> (Rn) */
        todo!()
    }

    pub fn STSPR(&mut self, args: OpCodeArgs) {
        /* PR -> Rn */
        todo!()
    }

    pub fn STSMPR(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, PR -> (Rn) */
        todo!()
    }

    pub fn SYNCO(&mut self, args: OpCodeArgs) {
        /*
         Prevents the next instruction from being issued until instructions
         issued before this instruction has been completed.
        */
        todo!()
    }

    pub fn TRAPA(&mut self, args: OpCodeArgs) {
        /*
         SH1*,SH2*: PC/SR -> stack area, (imm*4 + VBR) -> PC SH3*,SH4*:
         PC/SR -> SPC/SSR, imm*4 -> TRA, 0x160 -> EXPEVT, VBR + 0x0100
         -> PC
        */
        todo!()
    }

    pub fn FMOV(&mut self, args: OpCodeArgs) {
        /* FRm -> FRn */
        todo!()
    }

    pub fn FMOV_LOAD(&mut self, args: OpCodeArgs) {
        /* (Rm) -> FRn */
        todo!()
    }

    pub fn FMOV_STORE(&mut self, args: OpCodeArgs) {
        /* FRm -> (Rn) */
        todo!()
    }

    pub fn FMOV_RESTORE(&mut self, args: OpCodeArgs) {
        /* (Rm) -> FRn, Rm+4 -> Rm */
        todo!()
    }

    pub fn FMOV_SAVE(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, FRm -> (Rn) */
        todo!()
    }

    pub fn FMOV_INDEX_LOAD(&mut self, args: OpCodeArgs) {
        /* (R0 + Rm) -> FRn */
        todo!()
    }

    pub fn FMOV_INDEX_STORE(&mut self, args: OpCodeArgs) {
        /* FRm -> (R0 + Rn) */
        todo!()
    }

    pub fn FMOV_DR(&mut self, args: OpCodeArgs) {
        /* DRm -> DRn */
        todo!()
    }

    pub fn FMOV_DRXD(&mut self, args: OpCodeArgs) {
        /* DRm -> XDn */
        todo!()
    }

    pub fn FMOV_XDDR(&mut self, args: OpCodeArgs) {
        /* XDm -> DRn */
        todo!()
    }

    pub fn FMOV_XDXD(&mut self, args: OpCodeArgs) {
        /* XDm -> XDn */
        todo!()
    }

    pub fn FMOV_LOAD_DR(&mut self, args: OpCodeArgs) {
        /* (Rm) -> DRn */
        todo!()
    }

    pub fn FMOV_LOAD_XD(&mut self, args: OpCodeArgs) {
        /* (Rm) -> XDn */
        todo!()
    }

    pub fn FMOV_STORE_DR(&mut self, args: OpCodeArgs) {
        /* DRm -> (Rn) */
        todo!()
    }

    pub fn FMOV_STORE_XD(&mut self, args: OpCodeArgs) {
        /* XDm -> (Rn) */
        todo!()
    }

    pub fn FMOV_RESTORE_DR(&mut self, args: OpCodeArgs) {
        /* (Rm) -> DRn, Rm + 8 -> Rm */
        todo!()
    }

    pub fn FMOV_RESTORE_XD(&mut self, args: OpCodeArgs) {
        /* (Rm) -> XDn, Rm+8 -> Rm */
        todo!()
    }

    pub fn FMOV_SAVE_DR(&mut self, args: OpCodeArgs) {
        /* Rn-8 -> Rn, DRm -> (Rn) */
        todo!()
    }

    pub fn FMOV_SAVE_XD(&mut self, args: OpCodeArgs) {
        /* Rn-8 -> Rn, (Rn) -> XDm */
        todo!()
    }

    pub fn FMOV_INDEX_LOAD_DR(&mut self, args: OpCodeArgs) {
        /* (R0 + Rm) -> DRn */
        todo!()
    }

    pub fn FMOV_INDEX_LOAD_XD(&mut self, args: OpCodeArgs) {
        /* (R0 + Rm) -> XDn */
        todo!()
    }

    pub fn FMOV_INDEX_STORE_DR(&mut self, args: OpCodeArgs) {
        /* DRm -> (R0 + Rn) */
        todo!()
    }

    pub fn FMOV_INDEX_STORE_XD(&mut self, args: OpCodeArgs) {
        /* XDm -> (R0 + Rn) */
        todo!()
    }

    pub fn FLDI0(&mut self, args: OpCodeArgs) {
        /* 0x00000000 -> FRn */
        todo!()
    }

    pub fn FLDI1(&mut self, args: OpCodeArgs) {
        /* 0x3F800000 -> FRn */
        todo!()
    }

    pub fn FLDS(&mut self, args: OpCodeArgs) {
        /* FRm -> FPUL */
        todo!()
    }

    pub fn FSTS(&mut self, args: OpCodeArgs) {
        /* FPUL -> FRn */
        todo!()
    }

    pub fn FABS(&mut self, args: OpCodeArgs) {
        /* FRn & 0x7FFFFFFF -> FRn */
        todo!()
    }

    pub fn FNEG(&mut self, args: OpCodeArgs) {
        /* FRn ^ 0x80000000 -> FRn */
        todo!()
    }

    pub fn FADD(&mut self, args: OpCodeArgs) {
        /* FRn + FRm -> FRn */
        todo!()
    }

    pub fn FSUB(&mut self, args: OpCodeArgs) {
        /* FRn - FRm -> FRn */
        todo!()
    }

    pub fn FMUL(&mut self, args: OpCodeArgs) {
        /* FRn * FRm -> FRn */
        todo!()
    }

    pub fn FMAC(&mut self, args: OpCodeArgs) {
        /* FR0 * FRm + FRn -> FRn */
        todo!()
    }

    pub fn FDIV(&mut self, args: OpCodeArgs) {
        /* FRn / FRm -> FRn */
        todo!()
    }

    pub fn FSQRT(&mut self, args: OpCodeArgs) {
        /* sqrt (FRn) -> FRn */
        todo!()
    }

    pub fn FCMP_EQ(&mut self, args: OpCodeArgs) {
        /* If FRn = FRm: 1 -> T Else: 0 -> T */
        todo!()
    }

    pub fn FCMP_GT(&mut self, args: OpCodeArgs) {
        /* If FRn > FRm: 1 -> T Else: 0 -> T */
        todo!()
    }

    pub fn FLOAT_single(&mut self, args: OpCodeArgs) {
        /* (float)FPUL -> FRn */
        todo!()
    }

    pub fn FTRC_single(&mut self, args: OpCodeArgs) {
        /* (long)FRm -> FPUL */
        todo!()
    }

    pub fn FIPR(&mut self, args: OpCodeArgs) {
        /* inner_product (FVm, FVn) -> FR[n+3] */
        todo!()
    }

    pub fn FTRV(&mut self, args: OpCodeArgs) {
        /* transform_vector (XMTRX, FVn) -> FVn */
        todo!()
    }

    pub fn FSRRA(&mut self, args: OpCodeArgs) {
        /* 1.0 / sqrt (FRn) -> FRn */
        todo!()
    }

    pub fn FSCA(&mut self, args: OpCodeArgs) {
        /*
         sin (FPUL) -> FRn cos (FPUL) -> FR[n+1]
        */
        todo!()
    }

    pub fn FABS_DUP(&mut self, args: OpCodeArgs) {
        /* DRn & 0x7FFFFFFFFFFFFFFF -> DRn */
        todo!()
    }

    pub fn FNEG_DUP(&mut self, args: OpCodeArgs) {
        /* DRn ^ 0x8000000000000000 -> DRn */
        todo!()
    }

    pub fn FADD_DUP(&mut self, args: OpCodeArgs) {
        /* DRn + DRm -> DRn */
        todo!()
    }

    pub fn FSUB_DUP(&mut self, args: OpCodeArgs) {
        /* DRn - DRm -> DRn */
        todo!()
    }

    pub fn FMUL_DUP(&mut self, args: OpCodeArgs) {
        /* DRn * DRm -> DRn */
        todo!()
    }

    pub fn FDIV_DUP(&mut self, args: OpCodeArgs) {
        /* DRn / DRm -> DRn */
        todo!()
    }

    pub fn FSQRT_DUP(&mut self, args: OpCodeArgs) {
        /* sqrt (DRn) -> DRn */
        todo!()
    }

    pub fn FCMP_EQ_DUP(&mut self, args: OpCodeArgs) {
        /* If DRn = DRm: 1 -> T Else: 0 -> T */
        todo!()
    }

    pub fn FCMP_GT_DUP(&mut self, args: OpCodeArgs) {
        /* If DRn > DRm: 1 -> T Else: 0 -> T */
        todo!()
    }

    pub fn FLOAT_double(&mut self, args: OpCodeArgs) {
        /* (double)FPUL -> DRn */
        todo!()
    }

    pub fn FTRC_double(&mut self, args: OpCodeArgs) {
        /* (long)DRm -> FPUL */
        todo!()
    }

    pub fn FCNVDS(&mut self, args: OpCodeArgs) {
        /* double_to_float (DRm) -> FPUL */
        todo!()
    }

    pub fn FCNVSD(&mut self, args: OpCodeArgs) {
        /* float_to_double (FPUL) -> DRn */
        todo!()
    }

    pub fn LDSFPSCR(&mut self, args: OpCodeArgs) {
        /* Rm -> FPSCR */
        todo!()
    }

    pub fn STSFPSCR(&mut self, args: OpCodeArgs) {
        /* FPSCR -> Rn */
        todo!()
    }

    pub fn LDSMFPSCR(&mut self, args: OpCodeArgs) {
        /* (Rm) -> FPSCR, Rm+4 -> Rm */
        todo!()
    }

    pub fn STSMFPSCR(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, FPSCR -> (Rn) */
        todo!()
    }

    pub fn LDSFPUL(&mut self, args: OpCodeArgs) {
        /* Rm -> FPUL */
        todo!()
    }

    pub fn STSFPUL(&mut self, args: OpCodeArgs) {
        /* FPUL -> Rn */
        todo!()
    }

    pub fn LDSMFPUL(&mut self, args: OpCodeArgs) {
        /* (Rm) -> FPUL, Rm+4 -> Rm */
        todo!()
    }

    pub fn STSMFPUL(&mut self, args: OpCodeArgs) {
        /* Rn-4 -> Rn, FPUL -> (Rn) */
        todo!()
    }

    pub fn FRCHG(&mut self, args: OpCodeArgs) {
        /*
         If FPSCR.PR = 0: ~FPSCR.FR -> FPSCR.FR Else: Undefined Operation
        */
        todo!()
    }

    pub fn FSCHG(&mut self, args: OpCodeArgs) {
        /*
         If FPSCR.PR = 0: ~FPSCR.SZ -> FPSCR.SZ Else: Undefined Operation
        */
        todo!()
    }

    pub fn FPCHG(&mut self, args: OpCodeArgs) {
        /* ~FPSCR.PR -> FPSCR.PR */
        todo!()
    }
}
